
/* File boot.s */
/* используется ассемблер GNU */
/* Объявляем константы для заголовка Multiboot1. */
.set ALIGN, 1<<0               /* выровнять загруженные модули по границам страниц */
.set MEMINFO, 1<<1             /* предоставить карту памяти */
.set FLAGS, ALIGN | MEMINFO    /* это поле 'флагов' Multiboot */
.set MAGIC, 0x1BADB002         /* 'магическое число' позволяет загрузчику найти заголовок */
.set CHECKSUM, -(MAGIC + FLAGS) /* контрольная сумма вышеперечисленного, чтобы доказать, что мы multiboot */

/*
Объявляем заголовок Multiboot, который помечает программу как ядро.
Это "магические" значения, задокументированные в стандарте Multiboot.
Загрузчик будет искать эту сигнатуру в первых 8 KiB файла ядра, выровненную по 32-битной границе. 
Сигнатура находится в своей секции, чтобы гарантировать, что заголовок будет 
принудительно размещен в пределах первых 8 KiB файла ядра.
*/
.section .multiboot
.align 4
.long MAGIC
.long FLAGS
.long CHECKSUM

/*
Стандарт Multiboot не определяет значение регистра указателя стека (esp), 
и предоставление стека ложится на ядро. Здесь выделяется место для небольшого стека: 
создается символ в его нижней части (stack_bottom), затем выделяется 16384 байта (16 KiB) для него, 
и, наконец, создается символ в верхней части (stack_top). Стек на x86 растет вниз. 
Стек находится в своей секции (.bss), чтобы его можно было пометить как nobits, 
что уменьшает размер файла ядра, поскольку он не содержит неинициализированный стек. 
Стек на x86 должен быть выровнен по 16-байтовой границе, согласно стандарту System V ABI.
*/
.section .bss
.align 16
stack_bottom:
.skip 16384 # 16 KiB
stack_top:

/*
Скрипт линковщика (линкера) указывает _start как точку входа в ядро,
и загрузчик перейдет к этой позиции, как только ядро будет загружено.
Нет смысла возвращаться из этой функции, так как загрузчик уже ушел.
*/
.section .text
.global _start
.type _start, @function
_start:
	/*
	Загрузчик загрузил нас в 32-битный защищенный режим на машине x86.
	Прерывания отключены. Страничная адресация (Paging) отключена. 
    Ядро имеет полный контроль над ЦП, без каких-либо функций ОС или библиотек. 
	*/

	/*
	Чтобы настроить стек, мы устанавливаем регистр esp (указатель стека)
	на верхнюю границу стека (stack_top), поскольку на системах x86 он
	растет вниз. Это обязательно делается на ассемблере, так как языки,
	такие как C, не могут функционировать без стека.
	*/
	mov $stack_top, %esp

	/*
	Это хорошее место для инициализации критического состояния процессора
	(например, загрузка GDT, включение Paging) перед входом в
	высокоуровневое ядро.
	*/

	/*
	Вход в высокоуровневое ядро. ABI требует, чтобы стек был 16-байтно
	выровнен во время вызова `call`. Поскольку мы не меняли выравнивание
	после установки `esp`, вызов является корректным.
	*/
	call kernel_main

	/*
	Если система завершила работу (вернулась из kernel_main, что
	нелогично для ОС), переводим компьютер в бесконечный цикл.
	1) cli: отключает прерывания.
	2) hlt: останавливает ЦП, ожидая прерывания.
	3) jmp 1b: возвращается к hlt в случае немаскируемого прерывания.
	*/
	cli
1:	hlt
	jmp 1b

/*
Устанавливаем размер символа _start. Полезно для отладки.
*/
.size _start, . - _start