

## Установка исходников (source code) и сборка std

```

rustup component add rust-src
rustup target add i686-unknown-none

# Если rustup все еще отказывается добавлять цель, это означает, что вы должны использовать компонент rust-src в процессе сборки

```

## Резюме процесса сборки Rust OS

Процесс сборки ядра ОС на Rust для нестандартной 32-битной цели (i686-unknown-none) требовал пяти основных этапов настройки, каждый из которых решал критическую проблему:

### 1. Конфигурация Цели

Проблема: Rust не поддерживает вашу цель (i686-unknown-none) по умолчанию.

Мы не можем использовать стандартные toolchain, так как они предполагают наличие ОС. Нам пришлось создать Спецификацию Цели (JSON), чтобы явно указать компилятору и линковщику, как работать с 32-битным ELF-форматом для отсутствующей ОС.

Решение: Создание i686-unknown-none.json с указанием архитектуры, линковщика (i686-elf-ld) и флагов.

### 2. Базовые Крейты

Проблема: Rust не мог найти libcore, необходимый для любого кода, и compiler_builtins для низкоуровневых функций.

Решение:  
1. Добавление `rustup component add rust-src`. 
2. Создание rust-toolchain.toml и переход на nightly (потому что stable не разрешает экспериментальные флаги). 
3. Использование флага `-Z unstable-options` в Makefile и настройки `build-std = ["core", "compiler_builtins"]` в .cargo/config.toml.

Нестабильные функции (`-Z build-std`): Возможность заставить Cargo перекомпилировать базовые крейты (core) для нашей нестандартной цели является экспериментальной функцией. Именно поэтому нам пришлось перейти на Nightly Toolchain и использовать флаг `-Z unstable-options`.

### 3. Проблема LLVM Layout 

Проблема: rustc/LLVM был слишком строг и требовал точного data-layout для 32-битного x86, иначе сборка libcore завершалась с ошибкой.

Решение: Копирование требуемого LLVM data-layout из лога ошибки в i686-unknown-none.json, чтобы удовлетворить компилятор.

### 4. Линковка Ядра 

Проблема: Линкер i686-elf-ld не мог найти стандартную библиотеку GCC (-lgcc), и нам требовалось точное размещение кода в памяти.

Решение: 
1. Удаление -lgcc из LDFLAGS (потому что compiler_builtins на Rust его заменил). 
2. Создание linker.ld для определения базового адреса (0x100000) и порядка секций (особенно .multiboot2).

### 5. Загрузка и Запуск 

Проблема: Ядро не было обнаружено загрузчиком (Multiboot2) или вызывало сбои при выполнении кода Rust.

Решение: 
1. Добавление Multiboot2 Header в секцию .multiboot2 в boot.s. 
2. Увеличение размера стека в boot.s (например, до 64KB) для предотвращения переполнения. 
3. Использование u16 и write_volatile для безопасного, атомарного и неоптимизируемого доступа к аппаратному видеобуферу.

---

**В итоге**, мы вручную воспроизвели все шаги, которые обычно делает стандартный Rust Toolchain при сборке для известной цели (например, x86_64 Linux), что является краеугольным камнем разработки ОС на Rust.