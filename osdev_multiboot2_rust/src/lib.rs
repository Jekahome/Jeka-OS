// src/main.rs

// Отключаем стандартную библиотеку Rust (которая зависит от ОС)
#![no_std]
// Отключаем стандартную точку входа `main`
#![no_main]

use core::panic::PanicInfo;
use core::ptr::write_volatile;

// Импортируем нашу функцию вывода (из C++ или переписанную на Rust)
// Пока используем простейшую реализацию VGA
#[allow(dead_code)]
fn terminal_write(s: &str) {
    let vga_buffer = 0xb8000 as *mut u8;
    for (i, &byte) in s.as_bytes().iter().enumerate() {
        unsafe {
            // Пишем символ
            *vga_buffer.offset(i as isize * 2) = byte;
            // Устанавливаем цвет (белый на черном)
            *vga_buffer.offset(i as isize * 2 + 1) = 0x0F;
        }
    }
}

// =================================================================
// Точка входа
// =================================================================

// В Rust точка входа не может быть вызвана напрямую из ассемблера,
// поэтому мы используем атрибут #[no_mangle] и extern "C".
// Она соответствует сигнатуре kernel_main, которую мы вызываем в boot.s.

#[no_mangle]
pub extern "C" fn kernel_main(multiboot_magic: u32, _multiboot_addr: u32) -> ! {
    /*  
        Упрощение кода очистки экрана VGA.
        Запись сразу символа и цвета одним 16-битным словом - это напрямую соответствует 
        аппаратному представлению ячейки VGA (16 бит). 
        Этот подход намного чище и безопаснее в контексте ядер ОС, 
        так как он минимизирует количество сгенерированного кода и избегает проблем 
        с неявным выравниванием и порядком байтов.
    */
    // Адрес видеобуфера VGA
    let vga_buffer_ptr = 0xb8000 as *mut u16; // Используем u16, чтобы записывать сразу 2 байта (символ + цвет)

    // Символ: Пробел (0x20) и Атрибут: Серо-на-черном (0x07)
    let blank_char: u16 = 0x0720; // 0x07 (цвет) << 8 | 0x20 (пробел)

    // Общее количество ячеек: 80 * 25 = 2000
    let mut i = 0;
    while i < 2000 {
        // Используем write_volatile, чтобы компилятор не удалил этот код
        unsafe {
            write_volatile(vga_buffer_ptr.offset(i as isize), blank_char);
        }
        i += 1;
    }

    /* 
        // Не рабочий вариант!
        // Очистка экрана VGA
        let vga_buffer_ptr = 0xb8000 as *mut u8;
        
        // Цикл для очистки 80x25 символов (2000 ячеек * 2 байта/ячейка = 4000 байт)
        for i in 0..2000 {
            unsafe {
                // Записываем пробел (0x20)
                *vga_buffer_ptr.offset((i * 2) as isize) = b' ';
                // Записываем атрибут (0x07 = серо-на-черном)
                *vga_buffer_ptr.offset((i * 2 + 1) as isize) = 0x07;
            }
        }
    */

    // Проверка Multiboot2 Header
    // Multiboot2 magic number - 0x36D76289
    if multiboot_magic != 0x36D76289 {
        terminal_write("ERROR: Not booted by Multiboot2 bootloader!");
    } else {
        terminal_write("Hello from RUST Multiboot2 Kernel!");
    }

    // Бесконечный цикл - обязательно!
    loop {}
}

// =================================================================
// Обработчик паники
// =================================================================

// Rust требует функцию-обработчик для паники, когда нет стандартной библиотеки.
// Эта функция вызывается, если ядро "паникует" (происходит невосстановимая ошибка).

#[panic_handler]
fn panic(_info: &PanicInfo) -> ! {
    // terminal_write("KERNEL PANIC!");
    loop {}
}