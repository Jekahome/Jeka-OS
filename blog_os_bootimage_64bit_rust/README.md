# Writing an OS in Rust 

[Philipp Oppermann's blog](https://github.com/phil-opp/blog_os)

[Rust OSDev](https://github.com/rust-osdev)

[Независимый бинарный файл на Rust](https://os.phil-opp.com/ru/freestanding-rust-binary/)

Создание проекта:
```
cargo new blog_os_bootimage_64bit_rust --bin --edition 2024
```

Для того, чтобы написать ядро операционной системы, нужен код, который не зависит от операционной системы и ее возможностей. Это означает, что нельзя использовать потоки, файлы, кучу, сети, случайные числа, стандартный вывод или другие возможности, которые зависят от ОС или определённого железа.

Это значит, что нельзя использовать большую часть стандартной библиотеки Rust, но остается множество других возможностей Rust, которые можно использовать. Например, итераторы, замыкания, сопоставление с образцом, Option и Result, форматирование строк и, конечно же, систему владения. 

## Шаг 1

**Первый шаг** в создании собственного ядра операционной системы — это создание исполняемого файла на Rust, который не будет подключать стандартную библиотеку.

По умолчанию, все Rust-крейты подключают стандартную библиотеку, которая зависит от возможностей операционной системы, таких как потоки, файлы, сети. Она также зависит от стандартной библиотки C libc, которая очень тесно взаимодействует с возможностями ОС. Так как мы хотим написать операционную систему, мы не можем использовать библиотеки, которые зависят от операционной системы. Поэтому необходимо отключить автоматические подключение стандартной библиотеки через [атрибут **no_std**](https://doc.rust-lang.org/1.30.0/book/first-edition/using-rust-without-the-standard-library.html)

Реализация паники, атрибут **pаnic_handler** определяет функцию, которая должна вызываться, когда происходит паника (panic). Стандартная библиотека предоставляет собственную функцию обработчика паники, но после отключения стандартной библиотеки мы должны написать собственный обработчик.

Эта функция никогда не должна возвратиться, и такая функция называется расходящейся [Diverging functions](https://doc.rust-lang.org/1.30.0/book/first-edition/functions.html#diverging-functions) и она возращает пустой тип **!**

```rust,no_run
#[panic_handler]
fn panic(_info: &PanicInfo) -> ! {
    loop {}
}
```

Отключение раскрутки стека при панике, раскрутка требует некоторых специльных библиотек ОС (например, libunwind для Linux или structured exception handling для Windows), так что мы не должны использовать её для нашей операционной системы.

```toml
# Cargo.toml
[profile.dev]
panic = "abort"

[profile.release]
panic = "abort"
```

Переопределение начальной точки входа программы. Система выполнения должна быть вызвана до main, поскольку ей необходимо инициализировать себя.
В типичном исполнимом файле Rust, который использует стандартную библиотеку, выполнение начинается в runtime-библиотеке C под названием crt0 (“C runtime zero”), которая создает окружение для C-приложения. Это включает создание стека и размещение аргументов в нужных регистрах. Затем C runtime вызывает точку входа для Rust-приложения, которая обозначается элементом языка **start**. Нам нужно напрямую переопределить точку входа crt0.

```rust,no_run
#[unsafe(no_mangle)] // не искажайте название этой функции
pub extern "C" fn _start() -> ! {
    // Эта функция является точкой входа, поскольку компоновщик ищет функцию.  
    // по умолчанию называется `_start`
    loop {}
}
```

Атрибут `#[unsafe(no_mangle)]` необходим, потому что на следующем этапе нам нужно сообщить имя функции точки входа `_start` компоновщику без искажения этого имени компилятором Rust.

Подсказать компоновщику не включать C runtime. Компоновщик — это программа, которая объединяет сгенерированный код в исполняемый файл. Конфигурация компоновщика по умолчанию предполагает, что наша программа зависит от C runtime, а это не так. 

Вы можете узнать тройку вашей хост-системы для которой компоновщик собирает исполняемый файл, выполнив команду `rustc --version --verbose`:

```
rustc 1.91.1 (ed61e7d7e 2025-11-07)
binary: rustc
commit-hash: ed61e7d7e242494fb7057f2657300d9e77bb4fcb
commit-date: 2025-11-07
host: x86_64-unknown-linux-gnu
release: 1.91.1
LLVM version: 21.1.2
```
Приведенный выше результат получен от системы x86_64 Linux. Мы видим, что тройка host — это x86_64-unknown-linux-gnu, которая включает архитектуру процессора (x86_64), производителя (unknown), операционную систему (linux) и [ABI](https://en.wikipedia.org/wiki/Application_binary_interface) (gnu).

Компилируя для тройки нашего хоста, компилятор Rust и компоновщик предполагают наличие базовой операционной системы, такой как Linux или Windows, которая по умолчанию использует C runtime, что вызывает ошибки компоновщика. Поэтому, чтобы избежать ошибок компоновщика, мы можем настроить компиляцию для другого окружения без базовой операционной системы.

Примером такого “голого” окружения является тройка `thumbv7em-none-eabihf`, которая описывает [ARM](https://en.wikipedia.org/wiki/ARM_architecture) архитектуру. Чтобы иметь возможность компилировать для этой системы, нам нужно добавить ее в rustup: `rustup target add thumbv7em-none-eabihf`. Это загружает копию стандартной библиотеки (и core) для системы. 

Теперь мы можем собрать наш независимый исполняемый файл для этой системы: `cargo build --target thumbv7em-none-eabihf` - мы кросс-компилируем наш исполняемый файл для голого железа. Поскольку система, под которую мы компилируем, не имеет операционной системы, компоновщик не пытается компоновать C runtime, и наша компиляция проходит успешно без каких-либо ошибок компоновщика.

В качестве альтернативы, мы можем скомпилировать его для хост-системы, передав дополнительные аргументы компоновщика:
```
# Linux
cargo rustc -- -C link-arg=-nostartfiles
# Windows
cargo rustc -- -C link-args="/ENTRY:_start /SUBSYSTEM:console"
# macOS
cargo rustc -- -C link-args="-e __start -static -nostartfiles"
```

## Шаг 2

[Минимально возможное ядро на Rust](https://os.phil-opp.com/ru/minimal-rust-kernel/)

Превращения нашего независимого бинарного файла в минимальное ядро операционной системы. Сюда входит создание custom target, объединение нашего исполняемого файла с загрузчиком и изучение, как вывести что-то на экран.

**Последовательность процессов запуска**

Когда вы включаете компьютер, он начинает выполнять код микропрограммы, который хранится в ПЗУ материнской платы. Этот код выполняет самотестирование при включении, определяет доступную оперативную память и выполняет предварительную инициализацию процессора и аппаратного обеспечения. После этого он ищет загрузочный диск и начинает загрузку ядра операционной системы.

Для архитектуры x86 существует два стандарта прошивки: “Basic Input/Output System“ (“Базовая система ввода/вывода” [BIOS](https://en.wikipedia.org/wiki/BIOS)) и более новый “Unified Extensible Firmware Interface” (“Унифицированный расширяемый интерфейс прошивки” [UEFI](https://en.wikipedia.org/wiki/Unified_Extensible_Firmware_Interface)).

**Запуск BIOS**

Почти все системы x86 имеют поддержку загрузки BIOS, включая более новые машины на базе UEFI, которые используют эмулированный BIOS. Это замечательно, потому что вы можете использовать одну и ту же логику загрузки на всех машинах из прошлых веков. Но такая широкая совместимость одновременно является и самым большим недостатком загрузки BIOS, поскольку это означает, что перед загрузкой процессор переводится в 16-битный режим совместимости под названием [реальный режим], чтобы архаичные загрузчики 1980-х годов все еще работали.

Если BIOS находит загрузочный диск, управление передается загрузчику, который представляет собой 512-байтовую порцию исполняемого кода, хранящуюся в начале диска. Большинство загрузчиков имеют размер более 512 байт, поэтому загрузчики обычно разделяются на небольшой **первый этап**, который помещается в 512 байт, и **второй этап**, который впоследствии загружается первым этапом.

Загрузчик должен определить расположение образа ядра на диске и загрузить его в память. Он также должен переключить процессор из 16-битного [реального режима](https://en.wikipedia.org/wiki/Real_mode) сначала в 32-битный [защищенный режим](https://en.wikipedia.org/wiki/Protected_mode), а затем в 64-битный [длинный режим](https://en.wikipedia.org/wiki/Long_mode). **Третий этап** - запросить определенную информацию (например, карту памяти) у BIOS и передать ее ядру ОС.

Так как написание загрузчика немного громоздко, поскольку требует использования языка ассемблера и множества неинтересных действий, таких как “запишите это магическое значение в этот регистр процессора”. Поэтому вместо этого предоставляем инструмент под названием [bootimage](https://github.com/rust-osdev/bootimage), который автоматически добавляет загрузчик к вашему ядру.

#### Стандарт Multiboot

Чтобы избежать того, что каждая операционная система реализует свой собственный загрузчик, который совместим только с одной ОС, Free Software Foundation в 1995 году создал открытый стандарт загрузчика под названием [Multiboot](https://wiki.osdev.org/Multiboot). Стандарт определяет интерфейс между загрузчиком и операционной системой, так что любой совместимый с Multiboot загрузчик может загружать любую совместимую с Multiboot операционную систему. Эталонной реализацией является [GNU GRUB](https://en.wikipedia.org/wiki/GNU_GRUB), который является самым популярным загрузчиком для систем Linux.

Чтобы сделать ядро совместимым с Multiboot, нужно просто вставить так называемый Multiboot заголовок в начало файла ядра. Это делает загрузку ОС в GRUB очень простой.

В этом варианте создания ядра не используется ни GRUB ни стандарт Multiboot.

### Минимально возможное ядро

Для создания операционной системы нам понадобятся некоторые экспериментальные возможности, которые доступны только на канале nightly, поэтому нам нужно установить nightly версию Rust: `rustup install nightly`

Что при запуске использовалась nightly версия пропишем это в файле rust-toolchain.toml:
```toml
[toolchain]
channel = "nightly"
```

#### Спецификация целевой платформы

Для нашей целевой системы нам требуются некоторые специальные параметры конфигурации (например, отсутствие базовой ОС), поэтому тройка `thumbv7em-none-eabihf` которую мы использовали на первом шаге и вообще ни одна из существующих целевых платформ нам не подходит. К счастью, Rust позволяет нам определить custom target через JSON-файл. 
 
Большинство полей требуется LLVM для генерации кода для данной платформы. Например, поле `data-layout` определяет размер различных типов целых чисел, чисел с плавающей точкой и указателей. Затем есть поля, которые Rust использует для условной компиляции, такие как `target-pointer-width`. Третий вид полей определяет, как должен быть собран крейт. Например, поле `pre-link-args` определяет аргументы, передаваемые компоновщику.

Файл x86_64-blog_os_bootimage_64bit_rust.json
```json
{
    "llvm-target": "x86_64-unknown-none",
    "data-layout": "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128",
    "arch": "x86_64",
    "target-endian": "little",
    "target-pointer-width": 64,
    "target-c-int-width": 32,
    "os": "none",
    "executables": true,
    "linker-flavor": "ld.lld",
    "linker": "rust-lld",
    "panic-strategy": "abort",
    "disable-redzone": true,
    "features": "-mmx,-sse,+soft-float",
    "rustc-abi": "x86-softfloat"
}
```

Вместо того чтобы использовать компоновщик по умолчанию платформы (который может не поддерживать цели Linux), мы используем кроссплатформенный компоновщик [LLD](https://lld.llvm.org/), поставляемый вместе с Rust, для компоновки нашего ядра.

Этот параметр `"panic-strategy": "abort"` указывает, что цель не поддерживает раскрутку стека при панике, поэтому вместо этого программа должна прерваться напрямую.

`"disable-redzone": true` мы пишем ядро, поэтому в какой-то момент нам понадобится обрабатывать прерывания. Чтобы сделать это безопасно, мы должны отключить определенную оптимизацию указателя стека, называемую [“красной зоной”](https://os.phil-opp.com/ru/red-zone/), поскольку в противном случае она приведет к повреждениям стека.

`"features": "-mmx,-sse,+soft-float"` поле features включает/выключает функции целевой платформы. Мы отключаем функции mmx и sse, добавляя к ним минус, и включаем функцию soft-float, добавляя к ней плюс. Обратите внимание, что между разными флагами не должно быть пробелов, иначе LLVM не сможет интерпретировать строку features. Чтобы избежать проблем с производительностью (в ядре из-за частых прерываний происходит сохранение/загрузка стека из регистров,а состояние SIMD очень велико 512-1600 байт) , мы [отключили SIMD](https://os.phil-opp.com/ru/disable-simd/) для нашего ядра (не для приложений, работающих поверх него!).

`"rustc-abi": "x86-softfloat"` регистры SIMD по умолчанию используется для операций с плавающей точкой на x86_64, но так как мы его отключили нам нужно   добавить функцию soft-float, которая эмулирует все операции с числами с плавающей точкой через программные функции, основанные на обычных целых числах.

И сразу автоматизируем установку цели при запуске cargo build что бы ее не указывать лишний раз. 

Файл .cargo/config.toml:
```toml
[build]
target = "x86_64-blog_os_bootimage_64bit_rust.json"
```

Теперь сборка будет происходить просто: `cargo build`

#### Функция build-std. Компиляция core

`core` библиотека содержит основные типы Rust, такие как Result, Option и итераторы, и неявно связана со всеми no_std модулями. Проблема в том, что корневая (core) библиотека распространяется вместе с компилятором Rust как прекомпилированная библиотека. Поэтому она действительна только для поддерживаемых тройных хостов (например, `x86_64-unknown-linux-gnu`), но не для нашей пользовательской целевой платформы. Если мы хотим скомпилировать код для других целевых платформ, нам нужно сначала перекомпилировать core для этих целей.

Фнкция `build-std` в `cargo` позволяет перекомпилировать `core` и другие стандартные библиотеки по требованию, вместо того, чтобы использовать предварительно скомпилированные версии, поставляемые вместе с установкой Rust.

Это говорит cargo, что он должен перекомпилировать библиотеки `core` и `compiler_builtins`.

Файл .cargo/config.toml:
```toml
[build]
target = "x86_64-blog_os_bootimage_64bit_rust.json"

[unstable]
build-std-features = ["compiler-builtins-mem"]
build-std = ["core", "compiler_builtins"]
```

Чтобы перекомпилировать эти библиотеки, cargo нужен доступ к исходному коду rust, который мы можем установить с помощью команды `rustup component add rust-src`.

Модуль compiler_builtins содержит реализации всех необходимых функций для работы с памятью, они просто отключены по умолчанию, чтобы не столкнуться с реализациями из С библиотеки. Мы можем включить их, установив флаг cargo `build-std-features = ["compiler-builtins-mem"]`. Как и флаг build-std, этот флаг может быть передан в командной строке как флаг `-Z` или настроен в таблице unstable в файле `.cargo/config.toml`. За кулисами этот флаг включает функцию `mem` крейта `compiler_builtins`. Это приводит к тому, что атрибут #[unsafe(no_mangle)] применяется к реализациям memcpy и т.п. из этого крейта, что делает их доступными для компоновщика.

#### Вывод на экран. VGA

Самым простым способом печати текста на экран на данном этапе является [текстовый буфер VGA](https://en.wikipedia.org/wiki/VGA-compatible_text_mode). Это специальная область памяти, сопоставленная с аппаратным обеспечением VGA, которая содержит содержимое, отображаемое на экране. Обычно он состоит из 25 строк, каждая из которых содержит 80 символьных ячеек. Каждая символьная ячейка отображает символ ASCII с некоторыми цветами переднего и заднего плана. 

Для печати “Hello World!” нам достаточно знать, что буфер расположен по адресу `0xb8000` и что каждая символьная ячейка состоит из байта ASCII и байта цвета.

В теле цикла for мы используем метод offset для записи байта строки и соответствующего байта цвета (`0xb` - светло-голубой).

```rust,no_run
static HELLO: &[u8] = b"Hello World!";

#[unsafe(no_mangle)]
pub extern "C" fn _start() -> ! {
    let vga_buffer = 0xb8000 as *mut u8;

    for (i, &byte) in HELLO.iter().enumerate() {
        unsafe {
            *vga_buffer.offset(i as isize * 2) = byte;
            *vga_buffer.offset(i as isize * 2 + 1) = 0xb;
        }
    }

    loop {}
}
```

## Запуск ядра

Теперь, когда у нас есть исполняемый файл, который делает что-то ощутимое, пришло время запустить его. Сначала нам нужно превратить наше скомпилированное ядро в загрузочный образ диска, связав его с загрузчиком. Затем мы можем запустить образ диска в виртуальной машине QEMU или загрузить его на реальном оборудовании с помощью USB-носителя.

### Создание загрузочного образа

Чтобы превратить наше скомпилированное ядро в загрузочный образ диска, нам нужно связать его с загрузчиком. Загрузчик отвечает за инициализацию процессора и загрузку нашего ядра.

Вместо того чтобы писать собственный загрузчик, который является самостоятельным проектом, мы используем модуль [bootloader](https://crates.io/crates/bootloader). Этот модуль реализует базовый BIOS-загрузчик без каких-либо C-зависимостей, только Rust и встроенный ассемблер. 

Чтобы использовать его для загрузки нашего ядра, нам нужно добавить зависимость от него:

Файл Cargo.toml:
```toml
[dependencies]
bootloader = "0.9"
```

Добавление загрузчика в качестве зависимости недостаточно для создания загрузочного образа диска. Проблема в том, что нам нужно связать наше ядро с загрузчиком после компиляции, но в cargo нет поддержки [скриптов после сборки](https://github.com/rust-lang/cargo/issues/545).

Для решения этой проблемы мы создали инструмент bootimage, который сначала компилирует ядро и загрузчик, а затем соединяет их вместе для создания загрузочного образа диска. 

Чтобы установить инструмент, выполните следующую команду в терминале: `cargo install bootimage`

Для запуска bootimage и сборки загрузчика вам необходимо установить компонент rustup llvm-tools-preview. 
Это можно сделать, выполнив команду: `rustup component add llvm-tools-preview`.

После установки bootimage и добавления компонента llvm-tools-preview мы можем создать образ загрузочного диска, выполнив команду: `cargo bootimage`

```
Created bootimage for `blog_os_bootimage_64bit_rust` at `/home/.../blog_os_bootimage_64bit_rust/target/x86_64-blog_os_bootimage_64bit_rust/debug/bootimage-blog_os_bootimage_64bit_rust.bin`
```
Мы видим, что инструмент перекомпилирует наше ядро с помощью cargo build, поэтому он автоматически подхватит все внесенные вами изменения. После этого он компилирует загрузчик, что может занять некоторое время. Как и все зависимости модулей, он собирается только один раз, а затем кэшируется, поэтому последующие сборки будут происходить гораздо быстрее. Наконец, bootimage объединяет загрузчик и ваше ядро в загрузочный образ диска.

После выполнения команды вы должны увидеть загрузочный образ диска с именем bootimage-blog_os_bootimage_64bit_rust.bin в каталоге target/x86_64-blog_os_bootimage_64bit_rust/debug. Вы можете загрузить его в виртуальной машине.

**Как этот работает?**

Инструмент bootimage выполняет следующие действия за кулисами:

* Компилирует наше ядро в файл ELF.
* Компилирует зависимость загрузчика как отдельный исполняемый файл.
* Он связывает байты ELF-файла ядра с загрузчиком.

При запуске загрузчик читает и разбирает приложенный файл ELF. Затем он сопоставляет сегменты программы с виртуальными адресами в таблицах страниц, обнуляет секцию `.bss` и устанавливает стек. Наконец, он считывает адрес точки входа (наша функция `_start`) и переходит к ней.

### Запуск через QEMU

Теперь мы можем загрузить образ диска в виртуальной машине. Чтобы загрузить его в [QEMU](https://www.qemu.org/), выполните следующую команду:

```
qemu-system-x86_64 -drive format=raw,file=target/x86_64-blog_os_bootimage_64bit_rust/debug/bootimage-blog_os_bootimage_64bit_rust.bin
 
```
 
### Настоящая машина

Также можно записать его на USB-накопитель и загрузить на реальной машине:

```
dd if=target/x86_64-blog_os_bootimage_64bit_rust/debug/bootimage-blog_os_bootimage_64bit_rust.bin of=/dev/sdX && sync
```

Где sdX - имя устройства вашего USB-накопителя. Внимательно проверьте, что вы выбрали правильное имя устройства, потому что все, что находится на этом устройстве, будет перезаписано.

После записи образа на USB-накопитель его можно запустить на реальном оборудовании, загрузившись с него. Для загрузки с USB-накопителя вам, вероятно, потребуется использовать специальное меню загрузки или изменить порядок загрузки в конфигурации BIOS. Обратите внимание, что в настоящее время это не работает на машинах с UEFI, так как модуль bootloader пока не имеет поддержки UEFI.

