# Использование C++ для ядра

Использование C++ для ядра — это популярный подход, так как он позволяет использовать ООП, RAII и другие мощные концепции для управления ресурсами, прерываниями и памятью.


## C++ vs. C: Особенности сборки Bare Metal

В контексте разработки ядра ОС (то есть, без стандартной библиотеки и без ОС), **сборка C++ является значительно более сложной и особенной, чем сборка C.**

Сам процесс компиляции и линковки ассемблера и кода (как мы делали с Rust) в обоих случаях требует кросс-компилятора и линкерного скрипта. Однако, C++ добавляет несколько критических уровней сложности, которых нет в C:


### 1. Рантайм C++ (C++ Runtime)

C++ вводит объекты, конструкторы, деструкторы и механизмы обработки исключений, которые требуют скрытой поддержки на этапе выполнения (Runtime).

| Аспект | Особенность C++ | Почему это сложно? |
| :--- | :--- | :--- |
| **Инициализация** | Вызов **статических конструкторов** и **глобальных объектов** до `main()`. | Компилятор генерирует скрытый код (обычно в секциях `.init_array` или `.ctors`), который должен быть вызван вашим ассемблерным загрузчиком (`_start`) **до** вызова вашей функции `kernel_main`. В C нет статических конструкторов, поэтому вызов `main` происходит сразу. |
| **Исключения** | Механизмы `try/catch`, раскрутка стека (`unwinding`). | Требует библиотеку поддержки, такую как **`libsupc++`** или **`libcxxabi`**. Эти библиотеки должны быть кросс-скомпилированы для вашей целевой архитектуры (`i686-elf`) и правильно слинкованы. В C исключений нет, поэтому и проблема отсутствует. |
| **RTTI** | Информация о типе во время выполнения (`dynamic_cast`, `typeid`). | Также требует поддержки со стороны рантайма C++, что увеличивает сложность линковки. |

### 2. Стандартная библиотека C++ (libstdc++)

В C++ код, даже если он использует `std::vector` или `std::string`, все равно зависит от базовой стандартной библиотеки.

* **C:** Для Bare Metal достаточно просто слинковаться с **`libgcc`** (для низкоуровневых функций, таких как деление, если вы не используете Rust-эквиваленты) и проигнорировать стандартную библиотеку C (`libc`).
* **C++:** Чтобы использовать даже минимальные возможности C++ (например, `new/delete` для аллокации), вам нужен *полный* рантайм C++ (`libsupc++`). Для создания ядра необходимо собрать его с флагом **`-fno-exceptions`** и **`-fno-rtti`**, чтобы минимизировать зависимости, а затем переопределить функции аллокации (`operator new` и `operator delete`).

### 3. Линковка C++ и Name Mangling

* **C:** Функции имеют простые имена (например, `kernel_main`).
* **C++:** Компилятор C++ "украшает" имена функций (Name Mangling) для поддержки перегрузки функций. Если вы хотите вызвать функцию C++ из ассемблера (например, вашу точку входа), она должна быть объявлена с **`extern "C"`**, чтобы предотвратить Name Mangling и обеспечить совместимость с ассемблером и C-кодом.

### 4. Процесс сборки

Сборка C++ ядра обычно включает **дополнительный шаг** по сравнению с C:

1.  **Сборка C-кода/Ассемблера**
2.  **Сборка C++-кода** (обычно с `g++`, а не `gcc`).
3.  **Линковка:** Включает **четыре** основных компонента: ассемблер, код C++, `libgcc` и **`libsupc++`** (C++ Runtime). 

Таким образом, для C++ требуется более сложная настройка линкера и начального кода загрузчика, чтобы правильно инициализировать среду C++ до вызова вашей главной функции ядра.

## Вывод

В то время как C-ядро просто вызывает `main()`, **C++-ядро должно сначала выполнить скрытую работу по инициализации рантайма**, чтобы обеспечить среду, необходимую для работы всех его функций (конструкторов, исключений и т.д.). Эта настройка "вручную" значительно усложняет процесс.

 
